[16:57:53] [main/INFO]: ModLauncher running: args [--username, 123, --version, PureCraft, --gameDir, D:\Desktop\client\.minecraft, --assetsDir, D:\Desktop\client\.minecraft\assets, --assetIndex, 1.18, --uuid, 75f41576c9ae3be19e5af6091a7fa867, --accessToken, 7676767676767676, --clientId, ${clientid}, --xuid, ${auth_xuid}, --userType, mojang, --versionType, HMCL 3.5.2.216, --width, 854, --height, 480, --tweakClass, optifine.OptiFineTweaker, --launchTarget, forgeclient, --fml.forgeVersion, 39.0.40, --fml.mcVersion, 1.18.1, --fml.forgeGroup, net.minecraftforge, --fml.mcpVersion, 20211210.034407]
[16:57:53] [main/INFO]: ModLauncher 9.0.7+91+master.8569cdf starting: java version 17.0.1 by Oracle Corporation
[16:57:53] [main/INFO]: OptiFineTransformationService.onLoad
[16:57:53] [main/INFO]: OptiFine ZIP file URL: union:/D:/Desktop/client/.minecraft/libraries/optifine/OptiFine/1.18.1_HD_U_H4/OptiFine-1.18.1_HD_U_H4.jar%2324!
[16:57:53] [main/INFO]: OptiFine ZIP file: D:\Desktop\client\.minecraft\libraries\optifine\OptiFine\1.18.1_HD_U_H4\OptiFine-1.18.1_HD_U_H4.jar
[16:57:53] [main/INFO]: Target.PRE_CLASS is available
[16:57:53] [main/INFO]: SpongePowered MIXIN Subsystem Version=0.8.5 Source=union:/D:/Desktop/client/.minecraft/libraries/org/spongepowered/mixin/0.8.5/mixin-0.8.5.jar%2319! Service=ModLauncher Env=CLIENT
[16:57:53] [main/INFO]: OptiFineTransformationService.initialize
[16:57:53] [main/INFO]: Found mod file [MrCrayfish] cgm-1.1.2-1.18.1.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file additional-guns-0.4.2-1.18.1.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file appleskin-forge-mc1.18-2.2.0.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file BetterPvP_21.23.1_Forge_1.18.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file car-1.18.1-1.0.1.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file carryon-1.18.1-1.17.0.7.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file corpse-1.18.1-1.0.1.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file custom-crosshair-mod-v1.3.8-forge-mc1.18.1.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file ferritecore-4.0.0-forge.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file flywheel-forge-1.18-0.5.1.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file framework-0.2.2-1.18.1.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file InventoryHud_[1.18].forge-3.4.4.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file InventoryProfilesNext-forge-1.18-1.2.3.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file jei-1.18.1-9.2.1.69.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file jixiudongli.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file krypton-1.0.0.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file Patchouli-1.18.1-64.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file simpleplanes-1.18-4.6.3.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file Skewers-1.18.1-1.1.0.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file sophisticatedbackpacks-1.18.1-3.15.1.505.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file torohealth-1.18-forge-2.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file voicechat-forge-1.18.1-2.2.5.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:53] [main/INFO]: Found mod file XaerosWorldMap_1.19.1_Forge_1.18.jar of type MOD with locator {mods folder locator at D:\Desktop\client\.minecraft\mods}
[16:57:54] [main/INFO]: Found mod file fmlcore-1.18.1-39.0.40.jar of type LIBRARY with locator net.minecraftforge.fml.loading.moddiscovery.MinecraftLocator@423e4cbb
[16:57:54] [main/INFO]: Found mod file javafmllanguage-1.18.1-39.0.40.jar of type LANGPROVIDER with locator net.minecraftforge.fml.loading.moddiscovery.MinecraftLocator@423e4cbb
[16:57:54] [main/INFO]: Found mod file mclanguage-1.18.1-39.0.40.jar of type LANGPROVIDER with locator net.minecraftforge.fml.loading.moddiscovery.MinecraftLocator@423e4cbb
[16:57:54] [main/INFO]: Found mod file client-1.18.1-20211210.034407-srg.jar of type MOD with locator net.minecraftforge.fml.loading.moddiscovery.MinecraftLocator@423e4cbb
[16:57:54] [main/INFO]: Found mod file forge-1.18.1-39.0.40-universal.jar of type MOD with locator net.minecraftforge.fml.loading.moddiscovery.MinecraftLocator@423e4cbb
[16:57:55] [main/INFO]: OptiFineTransformationService.transformers
[16:57:55] [main/INFO]: Targets: 342
[16:57:55] [main/INFO]: additionalClassesLocator: [optifine., net.optifine.]
[16:57:56] [main/INFO]: Compatibility level set to JAVA_17
[16:57:56] [main/INFO]: Successfully loaded Mixin Connector [de.maxhenkel.car.MixinConnector]
[16:57:56] [main/INFO]: Launching target 'forgeclient' with arguments [--version, PureCraft, --gameDir, D:\Desktop\client\.minecraft, --assetsDir, D:\Desktop\client\.minecraft\assets, --uuid, 75f41576c9ae3be19e5af6091a7fa867, --username, 123, --assetIndex, 1.18, --accessToken, 7676767676767676, --clientId, ${clientid}, --xuid, ${auth_xuid}, --userType, mojang, --versionType, HMCL 3.5.2.216, --width, 854, --height, 480, --tweakClass, optifine.OptiFineTweaker]
[16:57:56] [main/WARN]: Reference map 'additionalguns.refmap.json' for additionalguns.mixins.json could not be read. If this is a development environment you can ignore this message
[16:57:57] [main/WARN]: Reference map 'simpleplanes.refmap.json' for simpleplanes.mixins.json could not be read. If this is a development environment you can ignore this message
[16:58:09] [Render thread/WARN]: Assets URL 'union:/D:/Desktop/client/.minecraft/libraries/net/minecraft/client/1.18.1-20211210.034407/client-1.18.1-20211210.034407-srg.jar%2377!/assets/.mcassetsroot' uses unexpected schema
[16:58:09] [Render thread/WARN]: Assets URL 'union:/D:/Desktop/client/.minecraft/libraries/net/minecraft/client/1.18.1-20211210.034407/client-1.18.1-20211210.034407-srg.jar%2377!/data/.mcassetsroot' uses unexpected schema
[16:58:09] [Render thread/INFO]: Environment: authHost='https://authserver.mojang.com', accountsHost='https://api.mojang.com', sessionHost='https://sessionserver.mojang.com', servicesHost='https://api.minecraftservices.com', name='PROD'
[16:58:11] [Render thread/ERROR]: Failed to verify authentication
com.mojang.authlib.exceptions.InvalidCredentialsException: Status: 401
	at com.mojang.authlib.exceptions.MinecraftClientHttpException.toAuthenticationException(MinecraftClientHttpException.java:56) ~[authlib-3.2.38.jar%2340!:?]
	at com.mojang.authlib.yggdrasil.YggdrasilUserApiService.fetchProperties(YggdrasilUserApiService.java:132) ~[authlib-3.2.38.jar%2340!:?]
	at com.mojang.authlib.yggdrasil.YggdrasilUserApiService.<init>(YggdrasilUserApiService.java:44) ~[authlib-3.2.38.jar%2340!:?]
	at com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService.createUserApiService(YggdrasilAuthenticationService.java:153) ~[authlib-3.2.38.jar%2340!:?]
	at net.minecraft.client.Minecraft.m_193585_(Minecraft.java:599) ~[client-1.18.1-20211210.034407-srg.jar%2377!:?]
	at net.minecraft.client.Minecraft.<init>(Minecraft.java:401) ~[client-1.18.1-20211210.034407-srg.jar%2377!:?]
	at net.minecraft.client.main.Main.main(Main.java:169) ~[client-1.18.1-20211210.034407-srg.jar%2377!:?]
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:?]
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[?:?]
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:?]
	at java.lang.reflect.Method.invoke(Method.java:568) ~[?:?]
	at net.minecraftforge.fml.loading.targets.CommonClientLaunchHandler.lambda$launchService$0(CommonClientLaunchHandler.java:45) ~[fmlloader-1.18.1-39.0.40.jar%2323!:?]
	at cpw.mods.modlauncher.LaunchServiceHandlerDecorator.launch(LaunchServiceHandlerDecorator.java:37) [modlauncher-9.0.7.jar%235!:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:53) [modlauncher-9.0.7.jar%235!:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:71) [modlauncher-9.0.7.jar%235!:?]
	at cpw.mods.modlauncher.Launcher.run(Launcher.java:106) [modlauncher-9.0.7.jar%235!:?]
	at cpw.mods.modlauncher.Launcher.main(Launcher.java:77) [modlauncher-9.0.7.jar%235!:?]
	at cpw.mods.modlauncher.BootstrapLaunchConsumer.accept(BootstrapLaunchConsumer.java:26) [modlauncher-9.0.7.jar%235!:?]
	at cpw.mods.modlauncher.BootstrapLaunchConsumer.accept(BootstrapLaunchConsumer.java:23) [modlauncher-9.0.7.jar%235!:?]
	at cpw.mods.bootstraplauncher.BootstrapLauncher.main(BootstrapLauncher.java:90) [bootstraplauncher-0.1.17.jar:?]
Caused by: com.mojang.authlib.exceptions.MinecraftClientHttpException: Status: 401
	at com.mojang.authlib.minecraft.client.MinecraftClient.readInputStream(MinecraftClient.java:78) ~[authlib-3.2.38.jar%2340!:?]
	at com.mojang.authlib.minecraft.client.MinecraftClient.get(MinecraftClient.java:48) ~[authlib-3.2.38.jar%2340!:?]
	at com.mojang.authlib.yggdrasil.YggdrasilUserApiService.fetchProperties(YggdrasilUserApiService.java:113) ~[authlib-3.2.38.jar%2340!:?]
	... 18 more
[16:58:11] [Render thread/INFO]: Setting user: 123
[16:58:11] [Render thread/INFO]: Backend library: LWJGL version 3.2.2 SNAPSHOT
[16:58:12] [Render thread/INFO]: [OptiFine] 
[16:58:12] [Render thread/INFO]: [OptiFine] OptiFine_1.18.1_HD_U_H4
[16:58:12] [Render thread/INFO]: [OptiFine] Build: 20211212-175054
[16:58:12] [Render thread/INFO]: [OptiFine] OS: Windows 10 (amd64) version 10.0
[16:58:12] [Render thread/INFO]: [OptiFine] Java: 17.0.1, Oracle Corporation
[16:58:12] [Render thread/INFO]: [OptiFine] VM: Java HotSpot(TM) 64-Bit Server VM (mixed mode, sharing), Oracle Corporation
[16:58:12] [Render thread/INFO]: [OptiFine] LWJGL: 3.3.0 Win32 WGL EGL OSMesa VisualC DLL
[16:58:12] [Render thread/INFO]: [OptiFine] OpenGL: AMD Radeon(TM) Vega 8 Graphics , version 3.2.14802 Core Profile Forward-Compatible Context 21.12.1 30.0.14011.3017, ATI Technologies Inc.
[16:58:12] [Render thread/INFO]: [OptiFine] OpenGL Version: 3.2.14802
[16:58:12] [Render thread/INFO]: [OptiFine] Maximum texture size: 16384x16384
[16:58:12] [VersionCheck/INFO]: [OptiFine] Checking for new version
[16:58:12] [Render thread/INFO]: [Shaders] OpenGL Version: 3.2.14802 Core Profile Forward-Compatible Context 21.12.1 30.0.14011.3017
[16:58:12] [Render thread/INFO]: [Shaders] Vendor:  ATI Technologies Inc.
[16:58:12] [Render thread/INFO]: [Shaders] Renderer: AMD Radeon(TM) Vega 8 Graphics 
[16:58:12] [Render thread/INFO]: [Shaders] Capabilities:  2.0  2.1  3.0  3.2  - 
[16:58:12] [Render thread/INFO]: [Shaders] GL_MAX_DRAW_BUFFERS: 8
[16:58:12] [Render thread/INFO]: [Shaders] GL_MAX_COLOR_ATTACHMENTS: 8
[16:58:12] [Render thread/INFO]: [Shaders] GL_MAX_TEXTURE_IMAGE_UNITS: 32
[16:58:12] [Render thread/INFO]: [Shaders] Load shaders configuration.
[16:58:12] [Render thread/INFO]: [Shaders] Save shaders configuration.
[16:58:12] [Render thread/INFO]: [Shaders] No shaderpack loaded.
[16:58:12] [Render thread/INFO]: [OptiFine] [Shaders] Delayed loading of item mappings after resources are loaded
[16:58:12] [Render thread/INFO]: [OptiFine] [Shaders] Delayed loading of entity mappings after resources are loaded
[16:58:12] [VersionCheck/INFO]: [OptiFine] java.io.FileNotFoundException: http://optifine.net/version/1.18.1/HD_U.txt
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Started reading file 'crosshair_config.ccmcfg'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'dot_enabled' to 'false'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'crosshair_adaptive_colour_enabled' to 'false'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'highlight_passive_enabled' to 'true'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'crosshair_height' to '4'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'visible_default' to 'true'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'outline_enabled' to 'true'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'crosshair_style' to 'CROSS'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'crosshair_scale' to '100'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'dot_colour' to '255/255/255/255'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'mod_enabled' to 'true'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'rainbow_enabled' to 'false'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'crosshair_width' to '4'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'highlight_hostile_enabled' to 'true'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'dynamic_bow_enabled' to 'true'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'crosshair_thickness' to '1'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'highlight_players_colour' to '60/60/240/255'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'itemcooldown_enabled' to 'true'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'crosshair_rotation' to '0'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'visible_holding_throwable_item' to 'true'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'highlight_hostile_colour' to '220/40/40/255'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'visible_holding_ranged_weapon' to 'true'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'visible_debug' to 'true'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'visible_spectator' to 'true'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'visible_hiddengui' to 'true'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'crosshair_gap' to '3'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'outline_colour' to '32/32/32/255'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'rainbow_speed' to '500'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'dynamic_attackindicator_enabled' to 'true'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'highlight_passive_colour' to '40/230/40/255'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'crosshair_colour' to '255/255/255/255'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'itemcooldown_colour' to '255/255/255/80'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'highlight_players_enabled' to 'true'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Set property 'visible_thirdperson' to 'false'.
[16:58:13] [modloading-worker-0/INFO]: [Config Manager (Read)] Finished reading file 'crosshair_config.ccmcfg'.
[16:58:13] [modloading-worker-0/INFO]: Forge mod loading, version 39.0.40, for MC 1.18.1 with MCP 20211210.034407
[16:58:13] [modloading-worker-0/INFO]: MinecraftForge v39.0.40 Initialized
[16:58:13] [modloading-worker-0/INFO]: Registered synced data key cgm:aiming for minecraft:player
[16:58:13] [modloading-worker-0/INFO]: Registered synced data key cgm:shooting for minecraft:player
[16:58:13] [modloading-worker-0/INFO]: Registered synced data key cgm:reloading for minecraft:player
[16:58:13] [modloading-worker-0/INFO]: Optifine detected.
[16:58:13] [modloading-worker-0/INFO]: No shader config found.
[16:58:13] [modloading-worker-0/INFO]: Successfully loaded com.jozufozu.flywheel.mixin.PausedPartialTickAccessor
[16:58:13] [modloading-worker-0/INFO]: Detected new forge version, registering events reflectively.
[16:58:17] [Render thread/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `milk`, expected `forge`. This could be a intended override, but in most cases indicates a broken mod.
[16:58:17] [Render thread/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `flowing_milk`, expected `forge`. This could be a intended override, but in most cases indicates a broken mod.
[16:58:17] [Render thread/INFO]: Potentially Dangerous alternative prefix `xaerominimap` for name `no_minimap`, expected `xaerobetterpvp`. This could be a intended override, but in most cases indicates a broken mod.
[16:58:17] [Render thread/INFO]: Potentially Dangerous alternative prefix `xaerominimap` for name `no_minimap_harmful`, expected `xaerobetterpvp`. This could be a intended override, but in most cases indicates a broken mod.
[16:58:17] [Render thread/INFO]: Potentially Dangerous alternative prefix `xaerominimap` for name `no_minimap_beneficial`, expected `xaerobetterpvp`. This could be a intended override, but in most cases indicates a broken mod.
[16:58:17] [Render thread/INFO]: Potentially Dangerous alternative prefix `xaerominimap` for name `no_entity_radar`, expected `xaerobetterpvp`. This could be a intended override, but in most cases indicates a broken mod.
[16:58:17] [Render thread/INFO]: Potentially Dangerous alternative prefix `xaerominimap` for name `no_entity_radar_harmful`, expected `xaerobetterpvp`. This could be a intended override, but in most cases indicates a broken mod.
[16:58:17] [Render thread/INFO]: Potentially Dangerous alternative prefix `xaerominimap` for name `no_entity_radar_beneficial`, expected `xaerobetterpvp`. This could be a intended override, but in most cases indicates a broken mod.
[16:58:17] [Render thread/INFO]: Potentially Dangerous alternative prefix `xaerominimap` for name `no_waypoints`, expected `xaerobetterpvp`. This could be a intended override, but in most cases indicates a broken mod.
[16:58:17] [Render thread/INFO]: Potentially Dangerous alternative prefix `xaerominimap` for name `no_waypoints_harmful`, expected `xaerobetterpvp`. This could be a intended override, but in most cases indicates a broken mod.
[16:58:17] [Render thread/INFO]: Potentially Dangerous alternative prefix `xaerominimap` for name `no_waypoints_beneficial`, expected `xaerobetterpvp`. This could be a intended override, but in most cases indicates a broken mod.
[16:58:17] [Render thread/INFO]: Potentially Dangerous alternative prefix `xaerominimap` for name `no_cave_maps`, expected `xaerobetterpvp`. This could be a intended override, but in most cases indicates a broken mod.
[16:58:17] [Render thread/INFO]: Potentially Dangerous alternative prefix `xaerominimap` for name `no_cave_maps_harmful`, expected `xaerobetterpvp`. This could be a intended override, but in most cases indicates a broken mod.
[16:58:17] [Render thread/INFO]: Potentially Dangerous alternative prefix `xaerominimap` for name `no_cave_maps_beneficial`, expected `xaerobetterpvp`. This could be a intended override, but in most cases indicates a broken mod.
[16:58:17] [Render thread/WARN]: [OptiFine] (Reflector) java.lang.ClassNotFoundException: sun.misc.SharedSecrets
[16:58:17] [Render thread/WARN]: [OptiFine] (Reflector) java.lang.ClassNotFoundException: jdk.internal.misc.SharedSecrets
[16:58:17] [Render thread/WARN]: [OptiFine] (Reflector) java.lang.ClassNotFoundException: sun.misc.VM
[16:58:17] [Render thread/WARN]: [OptiFine] (Reflector) java.lang.reflect.InaccessibleObjectException: Unable to make public static long jdk.internal.misc.VM.maxDirectMemory() accessible: module java.base does not "exports jdk.internal.misc" to module net.optifine
[16:58:18] [Render thread/INFO]: Narrator library for x64 successfully loaded
[16:58:19] [Render thread/INFO]: Reloading ResourceManager: Default, Mod Resources
[16:58:19] [Render thread/INFO]: [OptiFine] *** Reloading textures ***
[16:58:19] [Render thread/INFO]: [OptiFine] Resource packs: Mod Resources
[16:58:19] [Render thread/INFO]: [OptiFine] *** Reflector Forge ***
[16:58:19] [Render thread/INFO]: [OptiFine] (Reflector) Class not present: mods.betterfoliage.client.BetterFoliageClient
[16:58:19] [Render thread/INFO]: [OptiFine] *** Reflector Vanilla ***
[16:58:19] [Worker-Main-15/INFO]: [OptiFine] Multitexture: false
[16:58:19] [Worker-Main-10/INFO]: [OptiFine] Multitexture: false
[16:58:20] [Worker-Main-12/INFO]: [OptiFine] Multitexture: false
[16:58:20] [modloading-worker-0/WARN]: Configuration file D:\Desktop\client\.minecraft\config\patchouli-client.toml is not correct. Correcting
[16:58:20] [modloading-worker-0/WARN]: Incorrect key disableAdvancementLocking was corrected from null to its default, false. 
[16:58:20] [modloading-worker-0/WARN]: Incorrect key noAdvancementBooks was corrected from null to its default, []. 
[16:58:20] [modloading-worker-0/WARN]: Incorrect key testingMode was corrected from null to its default, false. 
[16:58:20] [modloading-worker-0/WARN]: Incorrect key inventoryButtonBook was corrected from null to its default, . 
[16:58:20] [modloading-worker-0/WARN]: Incorrect key useShiftForQuickLookup was corrected from null to its default, false. 
[16:58:20] [modloading-worker-0/WARN]: Incorrect key textOverflowMode was corrected from null to its default, RESIZE. 
[16:58:20] [Worker-Main-11/INFO]: [OptiFine] Multitexture: false
[16:58:20] [Worker-Main-13/INFO]: Compatibility version 14
[16:58:20] [Worker-Main-13/INFO]: Loading plugins
[16:58:20] [Worker-Main-13/INFO]: Loaded 0 plugin(s)
[16:58:20] [Worker-Main-13/INFO]: Initializing plugins
[16:58:20] [Worker-Main-13/INFO]: Initialized 0 plugin(s)
[16:58:20] [Worker-Main-13/INFO]: Compression will use Java 11, encryption will use Java
[16:58:21] [Worker-Main-12/INFO]: [OptiFine] Scaled non power of 2: jei:gui/icons/recipe_transfer, 7 -> 14
[16:58:21] [Forge Version Check/INFO]: [additionalguns] Starting version check at https://raw.githubusercontent.com/Mr-Pineapple/ModUpdateJSON/master/additionalguns/update.json
[16:58:21] [Forge Version Check/WARN]: Failed to process update information
java.net.ConnectException: null
	at jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:573) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:119) ~[java.net.http:?]
	at net.minecraftforge.fml.VersionChecker$1.openUrlString(VersionChecker.java:145) ~[fmlcore-1.18.1-39.0.40.jar%2378!:?]
	at net.minecraftforge.fml.VersionChecker$1.process(VersionChecker.java:183) ~[fmlcore-1.18.1-39.0.40.jar%2378!:?]
	at java.lang.Iterable.forEach(Iterable.java:75) [?:?]
	at net.minecraftforge.fml.VersionChecker$1.run(VersionChecker.java:128) [fmlcore-1.18.1-39.0.40.jar%2378!:?]
Caused by: java.net.ConnectException
	at jdk.internal.net.http.common.Utils.toConnectException(Utils.java:1047) ~[java.net.http:?]
	at jdk.internal.net.http.PlainHttpConnection.connectAsync(PlainHttpConnection.java:198) ~[java.net.http:?]
	at jdk.internal.net.http.AsyncSSLConnection.connectAsync(AsyncSSLConnection.java:56) ~[java.net.http:?]
	at jdk.internal.net.http.Http2Connection.createAsync(Http2Connection.java:378) ~[java.net.http:?]
	at jdk.internal.net.http.Http2ClientImpl.getConnectionFor(Http2ClientImpl.java:128) ~[java.net.http:?]
	at jdk.internal.net.http.ExchangeImpl.get(ExchangeImpl.java:93) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.establishExchange(Exchange.java:343) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsyncImpl0(Exchange.java:475) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsyncImpl(Exchange.java:380) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsync(Exchange.java:372) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.responseAsyncImpl(MultiExchange.java:408) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.lambda$responseAsyncImpl$7(MultiExchange.java:449) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:934) ~[?:?]
	at java.util.concurrent.CompletableFuture.uniHandleStage(CompletableFuture.java:950) ~[?:?]
	at java.util.concurrent.CompletableFuture.handle(CompletableFuture.java:2340) ~[?:?]
	at jdk.internal.net.http.MultiExchange.responseAsyncImpl(MultiExchange.java:439) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.lambda$responseAsync0$2(MultiExchange.java:341) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1150) ~[?:?]
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[?:?]
	at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1773) ~[?:?]
	at jdk.internal.net.http.HttpClientImpl$DelegatingExecutor.execute(HttpClientImpl.java:157) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture.completeAsync(CompletableFuture.java:2673) ~[?:?]
	at jdk.internal.net.http.MultiExchange.responseAsync(MultiExchange.java:294) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientImpl.sendAsync(HttpClientImpl.java:654) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:552) ~[java.net.http:?]
	... 5 more
Caused by: java.nio.channels.UnresolvedAddressException
	at sun.nio.ch.Net.checkAddress(Net.java:149) ~[?:?]
	at sun.nio.ch.Net.checkAddress(Net.java:157) ~[?:?]
	at sun.nio.ch.SocketChannelImpl.checkRemote(SocketChannelImpl.java:816) ~[?:?]
	at sun.nio.ch.SocketChannelImpl.connect(SocketChannelImpl.java:839) ~[?:?]
	at jdk.internal.net.http.PlainHttpConnection.lambda$connectAsync$0(PlainHttpConnection.java:183) ~[java.net.http:?]
	at java.security.AccessController.doPrivileged(AccessController.java:569) ~[?:?]
	at jdk.internal.net.http.PlainHttpConnection.connectAsync(PlainHttpConnection.java:185) ~[java.net.http:?]
	at jdk.internal.net.http.AsyncSSLConnection.connectAsync(AsyncSSLConnection.java:56) ~[java.net.http:?]
	at jdk.internal.net.http.Http2Connection.createAsync(Http2Connection.java:378) ~[java.net.http:?]
	at jdk.internal.net.http.Http2ClientImpl.getConnectionFor(Http2ClientImpl.java:128) ~[java.net.http:?]
	at jdk.internal.net.http.ExchangeImpl.get(ExchangeImpl.java:93) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.establishExchange(Exchange.java:343) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsyncImpl0(Exchange.java:475) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsyncImpl(Exchange.java:380) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsync(Exchange.java:372) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.responseAsyncImpl(MultiExchange.java:408) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.lambda$responseAsyncImpl$7(MultiExchange.java:449) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:934) ~[?:?]
	at java.util.concurrent.CompletableFuture.uniHandleStage(CompletableFuture.java:950) ~[?:?]
	at java.util.concurrent.CompletableFuture.handle(CompletableFuture.java:2340) ~[?:?]
	at jdk.internal.net.http.MultiExchange.responseAsyncImpl(MultiExchange.java:439) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.lambda$responseAsync0$2(MultiExchange.java:341) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1150) ~[?:?]
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[?:?]
	at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1773) ~[?:?]
	at jdk.internal.net.http.HttpClientImpl$DelegatingExecutor.execute(HttpClientImpl.java:157) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture.completeAsync(CompletableFuture.java:2673) ~[?:?]
	at jdk.internal.net.http.MultiExchange.responseAsync(MultiExchange.java:294) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientImpl.sendAsync(HttpClientImpl.java:654) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:552) ~[java.net.http:?]
	... 5 more
[16:58:21] [Forge Version Check/INFO]: [voicechat] Starting version check at https://maxhenkel.de/update/voicechat.json
[16:58:21] [Worker-Main-10/INFO]: Loading Better PVP Mod - Stage 1/2
[16:58:22] [Worker-Main-13/INFO]: Loading Xaero's World Map - Stage 1/2
[16:58:26] [Render thread/INFO]: Loading Better PVP Mod - Stage 2/2
[16:58:27] [Render thread/WARN]: Mod 'xaerobetterpvp' took 1.017 s to run a deferred task.
[16:58:27] [Render thread/INFO]: Loading Xaero's World Map - Stage 2/2
[16:58:27] [Render thread/INFO]: Xaero's WorldMap Mod: Better PVP found!
[16:58:27] [Forge Version Check/INFO]: [voicechat] Found status: OUTDATED Current: 1.18.1-2.2.5 Target: 1.18.1-2.2.8
[16:58:27] [Forge Version Check/INFO]: [inventoryhud] Starting version check at https://raw.githubusercontent.com/DmitryLovin/pluginUpdate/master/invupdate.json
[16:58:27] [Forge Version Check/WARN]: Failed to process update information
java.net.ConnectException: null
	at jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:573) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:119) ~[java.net.http:?]
	at net.minecraftforge.fml.VersionChecker$1.openUrlString(VersionChecker.java:145) ~[fmlcore-1.18.1-39.0.40.jar%2378!:?]
	at net.minecraftforge.fml.VersionChecker$1.process(VersionChecker.java:183) ~[fmlcore-1.18.1-39.0.40.jar%2378!:?]
	at java.lang.Iterable.forEach(Iterable.java:75) [?:?]
	at net.minecraftforge.fml.VersionChecker$1.run(VersionChecker.java:128) [fmlcore-1.18.1-39.0.40.jar%2378!:?]
Caused by: java.net.ConnectException
	at jdk.internal.net.http.common.Utils.toConnectException(Utils.java:1047) ~[java.net.http:?]
	at jdk.internal.net.http.PlainHttpConnection.connectAsync(PlainHttpConnection.java:198) ~[java.net.http:?]
	at jdk.internal.net.http.AsyncSSLConnection.connectAsync(AsyncSSLConnection.java:56) ~[java.net.http:?]
	at jdk.internal.net.http.Http2Connection.createAsync(Http2Connection.java:378) ~[java.net.http:?]
	at jdk.internal.net.http.Http2ClientImpl.getConnectionFor(Http2ClientImpl.java:128) ~[java.net.http:?]
	at jdk.internal.net.http.ExchangeImpl.get(ExchangeImpl.java:93) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.establishExchange(Exchange.java:343) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsyncImpl0(Exchange.java:475) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsyncImpl(Exchange.java:380) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsync(Exchange.java:372) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.responseAsyncImpl(MultiExchange.java:408) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.lambda$responseAsyncImpl$7(MultiExchange.java:449) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:934) ~[?:?]
	at java.util.concurrent.CompletableFuture.uniHandleStage(CompletableFuture.java:950) ~[?:?]
	at java.util.concurrent.CompletableFuture.handle(CompletableFuture.java:2340) ~[?:?]
	at jdk.internal.net.http.MultiExchange.responseAsyncImpl(MultiExchange.java:439) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.lambda$responseAsync0$2(MultiExchange.java:341) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1150) ~[?:?]
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[?:?]
	at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1773) ~[?:?]
	at jdk.internal.net.http.HttpClientImpl$DelegatingExecutor.execute(HttpClientImpl.java:157) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture.completeAsync(CompletableFuture.java:2673) ~[?:?]
	at jdk.internal.net.http.MultiExchange.responseAsync(MultiExchange.java:294) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientImpl.sendAsync(HttpClientImpl.java:654) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:552) ~[java.net.http:?]
	... 5 more
Caused by: java.nio.channels.UnresolvedAddressException
	at sun.nio.ch.Net.checkAddress(Net.java:149) ~[?:?]
	at sun.nio.ch.Net.checkAddress(Net.java:157) ~[?:?]
	at sun.nio.ch.SocketChannelImpl.checkRemote(SocketChannelImpl.java:816) ~[?:?]
	at sun.nio.ch.SocketChannelImpl.connect(SocketChannelImpl.java:839) ~[?:?]
	at jdk.internal.net.http.PlainHttpConnection.lambda$connectAsync$0(PlainHttpConnection.java:183) ~[java.net.http:?]
	at java.security.AccessController.doPrivileged(AccessController.java:569) ~[?:?]
	at jdk.internal.net.http.PlainHttpConnection.connectAsync(PlainHttpConnection.java:185) ~[java.net.http:?]
	at jdk.internal.net.http.AsyncSSLConnection.connectAsync(AsyncSSLConnection.java:56) ~[java.net.http:?]
	at jdk.internal.net.http.Http2Connection.createAsync(Http2Connection.java:378) ~[java.net.http:?]
	at jdk.internal.net.http.Http2ClientImpl.getConnectionFor(Http2ClientImpl.java:128) ~[java.net.http:?]
	at jdk.internal.net.http.ExchangeImpl.get(ExchangeImpl.java:93) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.establishExchange(Exchange.java:343) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsyncImpl0(Exchange.java:475) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsyncImpl(Exchange.java:380) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsync(Exchange.java:372) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.responseAsyncImpl(MultiExchange.java:408) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.lambda$responseAsyncImpl$7(MultiExchange.java:449) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:934) ~[?:?]
	at java.util.concurrent.CompletableFuture.uniHandleStage(CompletableFuture.java:950) ~[?:?]
	at java.util.concurrent.CompletableFuture.handle(CompletableFuture.java:2340) ~[?:?]
	at jdk.internal.net.http.MultiExchange.responseAsyncImpl(MultiExchange.java:439) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.lambda$responseAsync0$2(MultiExchange.java:341) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1150) ~[?:?]
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[?:?]
	at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1773) ~[?:?]
	at jdk.internal.net.http.HttpClientImpl$DelegatingExecutor.execute(HttpClientImpl.java:157) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture.completeAsync(CompletableFuture.java:2673) ~[?:?]
	at jdk.internal.net.http.MultiExchange.responseAsync(MultiExchange.java:294) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientImpl.sendAsync(HttpClientImpl.java:654) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:552) ~[java.net.http:?]
	... 5 more
[16:58:27] [Forge Version Check/INFO]: [cgm] Starting version check at https://raw.githubusercontent.com/MrCrayfish/ModUpdates/master/cgm/update.json
[16:58:27] [Forge Version Check/WARN]: Failed to process update information
java.net.ConnectException: null
	at jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:573) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:119) ~[java.net.http:?]
	at net.minecraftforge.fml.VersionChecker$1.openUrlString(VersionChecker.java:145) ~[fmlcore-1.18.1-39.0.40.jar%2378!:?]
	at net.minecraftforge.fml.VersionChecker$1.process(VersionChecker.java:183) ~[fmlcore-1.18.1-39.0.40.jar%2378!:?]
	at java.lang.Iterable.forEach(Iterable.java:75) [?:?]
	at net.minecraftforge.fml.VersionChecker$1.run(VersionChecker.java:128) [fmlcore-1.18.1-39.0.40.jar%2378!:?]
Caused by: java.net.ConnectException
	at jdk.internal.net.http.common.Utils.toConnectException(Utils.java:1047) ~[java.net.http:?]
	at jdk.internal.net.http.PlainHttpConnection.connectAsync(PlainHttpConnection.java:198) ~[java.net.http:?]
	at jdk.internal.net.http.AsyncSSLConnection.connectAsync(AsyncSSLConnection.java:56) ~[java.net.http:?]
	at jdk.internal.net.http.Http2Connection.createAsync(Http2Connection.java:378) ~[java.net.http:?]
	at jdk.internal.net.http.Http2ClientImpl.getConnectionFor(Http2ClientImpl.java:128) ~[java.net.http:?]
	at jdk.internal.net.http.ExchangeImpl.get(ExchangeImpl.java:93) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.establishExchange(Exchange.java:343) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsyncImpl0(Exchange.java:475) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsyncImpl(Exchange.java:380) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsync(Exchange.java:372) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.responseAsyncImpl(MultiExchange.java:408) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.lambda$responseAsyncImpl$7(MultiExchange.java:449) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:934) ~[?:?]
	at java.util.concurrent.CompletableFuture.uniHandleStage(CompletableFuture.java:950) ~[?:?]
	at java.util.concurrent.CompletableFuture.handle(CompletableFuture.java:2340) ~[?:?]
	at jdk.internal.net.http.MultiExchange.responseAsyncImpl(MultiExchange.java:439) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.lambda$responseAsync0$2(MultiExchange.java:341) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1150) ~[?:?]
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[?:?]
	at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1773) ~[?:?]
	at jdk.internal.net.http.HttpClientImpl$DelegatingExecutor.execute(HttpClientImpl.java:157) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture.completeAsync(CompletableFuture.java:2673) ~[?:?]
	at jdk.internal.net.http.MultiExchange.responseAsync(MultiExchange.java:294) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientImpl.sendAsync(HttpClientImpl.java:654) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:552) ~[java.net.http:?]
	... 5 more
Caused by: java.nio.channels.UnresolvedAddressException
	at sun.nio.ch.Net.checkAddress(Net.java:149) ~[?:?]
	at sun.nio.ch.Net.checkAddress(Net.java:157) ~[?:?]
	at sun.nio.ch.SocketChannelImpl.checkRemote(SocketChannelImpl.java:816) ~[?:?]
	at sun.nio.ch.SocketChannelImpl.connect(SocketChannelImpl.java:839) ~[?:?]
	at jdk.internal.net.http.PlainHttpConnection.lambda$connectAsync$0(PlainHttpConnection.java:183) ~[java.net.http:?]
	at java.security.AccessController.doPrivileged(AccessController.java:569) ~[?:?]
	at jdk.internal.net.http.PlainHttpConnection.connectAsync(PlainHttpConnection.java:185) ~[java.net.http:?]
	at jdk.internal.net.http.AsyncSSLConnection.connectAsync(AsyncSSLConnection.java:56) ~[java.net.http:?]
	at jdk.internal.net.http.Http2Connection.createAsync(Http2Connection.java:378) ~[java.net.http:?]
	at jdk.internal.net.http.Http2ClientImpl.getConnectionFor(Http2ClientImpl.java:128) ~[java.net.http:?]
	at jdk.internal.net.http.ExchangeImpl.get(ExchangeImpl.java:93) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.establishExchange(Exchange.java:343) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsyncImpl0(Exchange.java:475) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsyncImpl(Exchange.java:380) ~[java.net.http:?]
	at jdk.internal.net.http.Exchange.responseAsync(Exchange.java:372) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.responseAsyncImpl(MultiExchange.java:408) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.lambda$responseAsyncImpl$7(MultiExchange.java:449) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:934) ~[?:?]
	at java.util.concurrent.CompletableFuture.uniHandleStage(CompletableFuture.java:950) ~[?:?]
	at java.util.concurrent.CompletableFuture.handle(CompletableFuture.java:2340) ~[?:?]
	at jdk.internal.net.http.MultiExchange.responseAsyncImpl(MultiExchange.java:439) ~[java.net.http:?]
	at jdk.internal.net.http.MultiExchange.lambda$responseAsync0$2(MultiExchange.java:341) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1150) ~[?:?]
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510) ~[?:?]
	at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1773) ~[?:?]
	at jdk.internal.net.http.HttpClientImpl$DelegatingExecutor.execute(HttpClientImpl.java:157) ~[java.net.http:?]
	at java.util.concurrent.CompletableFuture.completeAsync(CompletableFuture.java:2673) ~[?:?]
	at jdk.internal.net.http.MultiExchange.responseAsync(MultiExchange.java:294) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientImpl.sendAsync(HttpClientImpl.java:654) ~[java.net.http:?]
	at jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:552) ~[java.net.http:?]
	... 5 more
[16:58:27] [Forge Version Check/INFO]: [framework] Starting version check at https://mrcrayfish.com/modupdatejson?id=framework
[16:58:31] [Forge Version Check/WARN]: Failed to process update information
java.lang.ClassCastException: class java.lang.Double cannot be cast to class java.lang.String (java.lang.Double and java.lang.String are in module java.base of loader 'bootstrap')
	at net.minecraftforge.fml.VersionChecker$1.process(VersionChecker.java:192) ~[fmlcore-1.18.1-39.0.40.jar%2378!:?]
	at java.lang.Iterable.forEach(Iterable.java:75) [?:?]
	at net.minecraftforge.fml.VersionChecker$1.run(VersionChecker.java:128) [fmlcore-1.18.1-39.0.40.jar%2378!:?]
[16:58:31] [Forge Version Check/INFO]: [car] Starting version check at https://maxhenkel.de/update/car.json
[16:58:31] [Forge Version Check/INFO]: [car] Found status: OUTDATED Current: 1.18.1-1.0.1 Target: 1.18.1-1.0.2
[16:58:31] [Forge Version Check/INFO]: [forge] Starting version check at https://files.minecraftforge.net/net/minecraftforge/forge/promotions_slim.json
[16:58:32] [Forge Version Check/INFO]: [forge] Found status: BETA_OUTDATED Current: 39.0.40 Target: 39.0.44
[16:58:32] [Forge Version Check/INFO]: [corpse] Starting version check at https://maxhenkel.de/update/corpse.json
[16:58:33] [Forge Version Check/INFO]: [corpse] Found status: OUTDATED Current: 1.18.1-1.0.1 Target: 1.18.1-1.0.2
[16:58:39] [Worker-Main-14/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[16:58:39] [Worker-Main-14/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[16:58:39] [Worker-Main-14/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[16:58:39] [Worker-Main-14/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[16:58:41] [Worker-Main-14/WARN]: Unable to resolve texture reference: #missing in additionalguns:item/ravens_claw
[16:58:41] [Worker-Main-14/WARN]: Unable to resolve texture reference: #missing in additionalguns:item/angled_grip
[16:58:41] [Worker-Main-14/WARN]: Unable to resolve texture reference: #missing in additionalguns:item/ace_of_spades
[16:58:41] [Worker-Main-14/WARN]: Unable to resolve texture reference: #missing in additionalguns:item/ammo_jcc
[16:58:41] [Worker-Main-14/WARN]: Unable to resolve texture reference: #missing in additionalguns:item/banshee
[16:58:41] [Worker-Main-14/INFO]: [OptiFine] Multitexture: false
[16:58:41] [Worker-Main-14/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[16:58:41] [Worker-Main-14/INFO]: [OptiFine] Multipass connected textures: false
[16:58:41] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/00_glass_white/glass_pane_white.properties
[16:58:41] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/00_glass_white/glass_white.properties
[16:58:41] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/01_glass_orange/glass_orange.properties
[16:58:41] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/01_glass_orange/glass_pane_orange.properties
[16:58:41] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/02_glass_magenta/glass_magenta.properties
[16:58:41] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/02_glass_magenta/glass_pane_magenta.properties
[16:58:41] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/03_glass_light_blue/glass_light_blue.properties
[16:58:41] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/03_glass_light_blue/glass_pane_light_blue.properties
[16:58:41] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/04_glass_yellow/glass_pane_yellow.properties
[16:58:41] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/04_glass_yellow/glass_yellow.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/05_glass_lime/glass_lime.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/05_glass_lime/glass_pane_lime.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/06_glass_pink/glass_pane_pink.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/06_glass_pink/glass_pink.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/07_glass_gray/glass_gray.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/07_glass_gray/glass_pane_gray.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/08_glass_light_gray/glass_light_gray.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/08_glass_light_gray/glass_pane_light_gray.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/09_glass_cyan/glass_cyan.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/09_glass_cyan/glass_pane_cyan.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/10_glass_purple/glass_pane_purple.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/10_glass_purple/glass_purple.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/11_glass_blue/glass_blue.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/11_glass_blue/glass_pane_blue.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/12_glass_brown/glass_brown.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/12_glass_brown/glass_pane_brown.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/13_glass_green/glass_green.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/13_glass_green/glass_pane_green.properties
[16:58:42] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/14_glass_red/glass_pane_red.properties
[16:58:43] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/14_glass_red/glass_red.properties
[16:58:43] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/15_glass_black/glass_black.properties
[16:58:43] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/15_glass_black/glass_pane_black.properties
[16:58:43] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/20_glass/glass.properties
[16:58:43] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/20_glass/glass_pane.properties
[16:58:43] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/21_tinted_glass/tinted_glass.properties
[16:58:43] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/30_bookshelf/bookshelf.properties
[16:58:43] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/40_sandstone/sandstone.properties
[16:58:43] [Worker-Main-14/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/41_red_sandstone/red_sandstone.properties
[16:58:43] [Worker-Main-14/INFO]: [OptiFine] Multipass connected textures: false
[16:58:43] [Worker-Main-14/INFO]: [OptiFine] BetterGrass: Parsing default configuration optifine/bettergrass.properties
[16:58:55] [Worker-Main-14/INFO]: [OptiFine] Mipmap levels: 4
[16:58:55] [Worker-Main-15/ERROR]: Using missing texture, unable to load car:textures/block/bio_diesel.png : java.io.FileNotFoundException: car:textures/block/bio_diesel.png
[16:58:55] [Worker-Main-11/ERROR]: Using missing texture, unable to load car:textures/block/methanol.png : java.io.FileNotFoundException: car:textures/block/methanol.png
[16:58:56] [Worker-Main-15/ERROR]: Using missing texture, unable to load car:textures/block/glycerin.png : java.io.FileNotFoundException: car:textures/block/glycerin.png
[16:58:56] [Worker-Main-11/ERROR]: Using missing texture, unable to load car:textures/block/canola_methanol_mix.png : java.io.FileNotFoundException: car:textures/block/canola_methanol_mix.png
[16:58:56] [Worker-Main-10/ERROR]: Using missing texture, unable to load minecraft:textures/block/stone_slab_top.png : java.io.FileNotFoundException: minecraft:textures/block/stone_slab_top.png
[16:58:56] [Worker-Main-12/ERROR]: Using missing texture, unable to load car:textures/block/canola_oil.png : java.io.FileNotFoundException: car:textures/block/canola_oil.png
[16:58:56] [Worker-Main-12/ERROR]: Using missing texture, unable to load minecraft:textures/block/hardened_clay_stained_gray.png : java.io.FileNotFoundException: minecraft:textures/block/hardened_clay_stained_gray.png
[16:58:56] [Worker-Main-14/INFO]: [OptiFine] Scaled non power of 2: additionalguns:item/aos_decal_3, 17 -> 32
[16:58:56] [Worker-Main-14/INFO]: [OptiFine] Scaled non power of 2: additionalguns:item/aos_decal_2, 17 -> 32
[16:58:56] [Worker-Main-14/INFO]: [OptiFine] Scaled too small texture: additionalguns:item/vintorez_stock, 8 -> 16
[16:58:56] [Worker-Main-14/INFO]: [OptiFine] Scaled non power of 2: additionalguns:item/ravens_claw_decal, 235 -> 240
[16:58:56] [Worker-Main-14/WARN]: Texture additionalguns:item/ravens_claw_decal with size 240x63 limits mip level from 4 to 0
[16:58:56] [Worker-Main-14/INFO]: [OptiFine] Scaled non power of 2: additionalguns:item/banshee_decal, 158 -> 160
[16:58:56] [Worker-Main-14/WARN]: minecraft:textures/atlas/blocks.png: dropping miplevel from 4 to 0, because of minimum power of two: 1
[16:58:58] [Worker-Main-14/INFO]: [OptiFine] Multitexture: false
[16:58:58] [Worker-Main-14/INFO]: [OptiFine] Sprite size: 64
[16:58:58] [Worker-Main-14/INFO]: [OptiFine] Mipmap levels: 6
[16:58:58] [Worker-Main-14/WARN]: Unused frames in sprite minecraft:missingno: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
[16:58:58] [Worker-Main-14/INFO]: [OptiFine] Multitexture: false
[16:58:58] [Worker-Main-14/INFO]: [OptiFine] Sprite size: 64
[16:58:58] [Worker-Main-14/INFO]: [OptiFine] Mipmap levels: 6
[16:58:58] [Worker-Main-14/WARN]: Unused frames in sprite minecraft:missingno: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
[16:58:58] [Worker-Main-14/INFO]: [OptiFine] Multitexture: false
[16:58:58] [Worker-Main-14/INFO]: [OptiFine] Sprite size: 64
[16:58:58] [Worker-Main-14/INFO]: [OptiFine] Mipmap levels: 6
[16:58:58] [Worker-Main-14/WARN]: Unused frames in sprite minecraft:missingno: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
[16:58:58] [Worker-Main-14/INFO]: [OptiFine] Multitexture: false
[16:58:58] [Worker-Main-14/INFO]: [OptiFine] Sprite size: 64
[16:58:58] [Worker-Main-14/INFO]: [OptiFine] Mipmap levels: 6
[16:58:58] [Worker-Main-14/WARN]: Unused frames in sprite minecraft:missingno: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
[16:58:58] [Worker-Main-14/INFO]: [OptiFine] Multitexture: false
[16:58:59] [Worker-Main-14/INFO]: [OptiFine] Sprite size: 64
[16:58:59] [Worker-Main-14/INFO]: [OptiFine] Mipmap levels: 6
[16:58:59] [Worker-Main-14/WARN]: Unused frames in sprite minecraft:missingno: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
[16:58:59] [Worker-Main-14/INFO]: [OptiFine] Multitexture: false
[16:58:59] [Worker-Main-14/INFO]: [OptiFine] Sprite size: 64
[16:58:59] [Worker-Main-14/INFO]: [OptiFine] Mipmap levels: 6
[16:58:59] [Worker-Main-14/WARN]: Unused frames in sprite minecraft:missingno: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
[16:58:59] [Render thread/INFO]: No shader config found.
[16:58:59] [Render thread/INFO]: Loading context 'flywheel:context/crumbling'
[16:58:59] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in mat4 a_i_transform;
in mat3 a_i_normalMat;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Instance i;
i.light = a_i_light;
i.color = a_i_color;
i.transform = a_i_transform;
i.normalMat = a_i_normalMat;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in mat4 a_i_transform;
in mat3 a_i_normalMat;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Instance i;
i.light = a_i_light;
i.color = a_i_color;
i.transform = a_i_transform;
i.normalMat = a_i_normalMat;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in vec3 a_i_pivot;
in vec4 a_i_rotation;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Oriented i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.pivot = a_i_pivot;
i.rotation = a_i_rotation;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in vec3 a_i_pivot;
in vec4 a_i_rotation;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Oriented i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.pivot = a_i_pivot;
i.rotation = a_i_rotation;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_pos;
in vec2 a_i_light;
in float a_i_offset;
in vec3 a_i_axis;
in vec4 a_i_rotation;
in vec3 a_i_rotationCenter;
in float a_i_speed;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Actor i;
i.pos = a_i_pos;
i.light = a_i_light;
i.offset = a_i_offset;
i.axis = a_i_axis;
i.rotation = a_i_rotation;
i.rotationCenter = a_i_rotationCenter;
i.speed = a_i_speed;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_pos;
in vec2 a_i_light;
in float a_i_offset;
in vec3 a_i_axis;
in vec4 a_i_rotation;
in vec3 a_i_rotationCenter;
in float a_i_speed;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Actor i;
i.pos = a_i_pos;
i.light = a_i_light;
i.offset = a_i_offset;
i.axis = a_i_axis;
i.rotation = a_i_rotation;
i.rotationCenter = a_i_rotationCenter;
i.speed = a_i_speed;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_instancePos;
in vec2 a_i_light;
in vec3 a_i_segmentOffset;
in vec3 a_i_pivot;
in float a_i_horizontalAngle;
in float a_i_intensity;
in float a_i_flapScale;
in float a_i_flapness;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Flap i;
i.instancePos = a_i_instancePos;
i.light = a_i_light;
i.segmentOffset = a_i_segmentOffset;
i.pivot = a_i_pivot;
i.horizontalAngle = a_i_horizontalAngle;
i.intensity = a_i_intensity;
i.flapScale = a_i_flapScale;
i.flapness = a_i_flapness;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_instancePos;
in vec2 a_i_light;
in vec3 a_i_segmentOffset;
in vec3 a_i_pivot;
in float a_i_horizontalAngle;
in float a_i_intensity;
in float a_i_flapScale;
in float a_i_flapness;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Flap i;
i.instancePos = a_i_instancePos;
i.light = a_i_light;
i.segmentOffset = a_i_segmentOffset;
i.pivot = a_i_pivot;
i.horizontalAngle = a_i_horizontalAngle;
i.intensity = a_i_intensity;
i.flapScale = a_i_flapScale;
i.flapness = a_i_flapness;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/INFO]: Loading context 'flywheel:context/world'
[16:58:59] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in mat4 a_i_transform;
in mat3 a_i_normalMat;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Instance i;
i.light = a_i_light;
i.color = a_i_color;
i.transform = a_i_transform;
i.normalMat = a_i_normalMat;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:58:59] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:58:59] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in mat4 a_i_transform;
in mat3 a_i_normalMat;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Instance i;
i.light = a_i_light;
i.color = a_i_color;
i.transform = a_i_transform;
i.normalMat = a_i_normalMat;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in vec3 a_i_pivot;
in vec4 a_i_rotation;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Oriented i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.pivot = a_i_pivot;
i.rotation = a_i_rotation;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in vec3 a_i_pivot;
in vec4 a_i_rotation;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Oriented i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.pivot = a_i_pivot;
i.rotation = a_i_rotation;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_pos;
in vec2 a_i_light;
in float a_i_offset;
in vec3 a_i_axis;
in vec4 a_i_rotation;
in vec3 a_i_rotationCenter;
in float a_i_speed;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Actor i;
i.pos = a_i_pos;
i.light = a_i_light;
i.offset = a_i_offset;
i.axis = a_i_axis;
i.rotation = a_i_rotation;
i.rotationCenter = a_i_rotationCenter;
i.speed = a_i_speed;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_pos;
in vec2 a_i_light;
in float a_i_offset;
in vec3 a_i_axis;
in vec4 a_i_rotation;
in vec3 a_i_rotationCenter;
in float a_i_speed;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Actor i;
i.pos = a_i_pos;
i.light = a_i_light;
i.offset = a_i_offset;
i.axis = a_i_axis;
i.rotation = a_i_rotation;
i.rotationCenter = a_i_rotationCenter;
i.speed = a_i_speed;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_instancePos;
in vec2 a_i_light;
in vec3 a_i_segmentOffset;
in vec3 a_i_pivot;
in float a_i_horizontalAngle;
in float a_i_intensity;
in float a_i_flapScale;
in float a_i_flapness;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Flap i;
i.instancePos = a_i_instancePos;
i.light = a_i_light;
i.segmentOffset = a_i_segmentOffset;
i.pivot = a_i_pivot;
i.horizontalAngle = a_i_horizontalAngle;
i.intensity = a_i_intensity;
i.flapScale = a_i_flapScale;
i.flapness = a_i_flapness;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_instancePos;
in vec2 a_i_light;
in vec3 a_i_segmentOffset;
in vec3 a_i_pivot;
in float a_i_horizontalAngle;
in float a_i_intensity;
in float a_i_flapScale;
in float a_i_flapness;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Flap i;
i.instancePos = a_i_instancePos;
i.light = a_i_light;
i.segmentOffset = a_i_segmentOffset;
i.pivot = a_i_pivot;
i.horizontalAngle = a_i_horizontalAngle;
i.intensity = a_i_intensity;
i.flapScale = a_i_flapScale;
i.flapness = a_i_flapness;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/INFO]: Loading context 'create:context/contraption'
[16:59:00] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in mat4 a_i_transform;
in mat3 a_i_normalMat;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Instance i;
i.light = a_i_light;
i.color = a_i_color;
i.transform = a_i_transform;
i.normalMat = a_i_normalMat;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in mat4 a_i_transform;
in mat3 a_i_normalMat;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Instance i;
i.light = a_i_light;
i.color = a_i_color;
i.transform = a_i_transform;
i.normalMat = a_i_normalMat;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in vec3 a_i_pivot;
in vec4 a_i_rotation;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Oriented i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.pivot = a_i_pivot;
i.rotation = a_i_rotation;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in vec3 a_i_pivot;
in vec4 a_i_rotation;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Oriented i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.pivot = a_i_pivot;
i.rotation = a_i_rotation;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_pos;
in vec2 a_i_light;
in float a_i_offset;
in vec3 a_i_axis;
in vec4 a_i_rotation;
in vec3 a_i_rotationCenter;
in float a_i_speed;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Actor i;
i.pos = a_i_pos;
i.light = a_i_light;
i.offset = a_i_offset;
i.axis = a_i_axis;
i.rotation = a_i_rotation;
i.rotationCenter = a_i_rotationCenter;
i.speed = a_i_speed;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_pos;
in vec2 a_i_light;
in float a_i_offset;
in vec3 a_i_axis;
in vec4 a_i_rotation;
in vec3 a_i_rotationCenter;
in float a_i_speed;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Actor i;
i.pos = a_i_pos;
i.light = a_i_light;
i.offset = a_i_offset;
i.axis = a_i_axis;
i.rotation = a_i_rotation;
i.rotationCenter = a_i_rotationCenter;
i.speed = a_i_speed;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_instancePos;
in vec2 a_i_light;
in vec3 a_i_segmentOffset;
in vec3 a_i_pivot;
in float a_i_horizontalAngle;
in float a_i_intensity;
in float a_i_flapScale;
in float a_i_flapness;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Flap i;
i.instancePos = a_i_instancePos;
i.light = a_i_light;
i.segmentOffset = a_i_segmentOffset;
i.pivot = a_i_pivot;
i.horizontalAngle = a_i_horizontalAngle;
i.intensity = a_i_intensity;
i.flapScale = a_i_flapScale;
i.flapness = a_i_flapness;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_instancePos;
in vec2 a_i_light;
in vec3 a_i_segmentOffset;
in vec3 a_i_pivot;
in float a_i_horizontalAngle;
in float a_i_intensity;
in float a_i_flapScale;
in float a_i_flapness;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Flap i;
i.instancePos = a_i_instancePos;
i.light = a_i_light;
i.segmentOffset = a_i_segmentOffset;
i.pivot = a_i_pivot;
i.horizontalAngle = a_i_horizontalAngle;
i.intensity = a_i_intensity;
i.flapScale = a_i_flapScale;
i.flapness = a_i_flapness;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:00] [Render thread/INFO]: Loading context 'create:context/contraption'
[16:59:00] [Render thread/ERROR]: Shader compilation log for create:contraption_structure: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:00] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Vertex {
    vec3 pos;
    vec4 color;
    vec2 texCoords;
    vec2 modelLight;
    vec3 normal;
};



#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v) {
    vec4 worldPos = vec4(v.pos, 1.);
    vec3 norm = v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = v.modelLight;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = v.color;
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec4 a_v_color;
in vec2 a_v_texCoords;
in vec2 a_v_modelLight;
in vec3 a_v_normal;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.color = a_v_color;
v.texCoords = a_v_texCoords;
v.modelLight = a_v_modelLight;
v.normal = a_v_normal;
BlockFrag o = vertex(v);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:01] [Render thread/ERROR]: Shader compilation log for create:contraption_structure: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:01] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Vertex {
    vec3 pos;
    vec4 color;
    vec2 texCoords;
    vec2 modelLight;
    vec3 normal;
};



#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v) {
    vec4 worldPos = vec4(v.pos, 1.);
    vec3 norm = v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = v.modelLight;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = v.color;
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:01] [Render thread/ERROR]: Shader compilation log for create:contraption_structure: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:01] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Vertex {
    vec3 pos;
    vec4 color;
    vec2 texCoords;
    vec2 modelLight;
    vec3 normal;
};



#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v) {
    vec4 worldPos = vec4(v.pos, 1.);
    vec3 norm = v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = v.modelLight;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = v.color;
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec4 a_v_color;
in vec2 a_v_texCoords;
in vec2 a_v_modelLight;
in vec3 a_v_normal;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.color = a_v_color;
v.texCoords = a_v_texCoords;
v.modelLight = a_v_modelLight;
v.normal = a_v_normal;
BlockFrag o = vertex(v);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[16:59:01] [Render thread/ERROR]: Shader compilation log for create:contraption_structure: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[16:59:01] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Vertex {
    vec3 pos;
    vec4 color;
    vec2 texCoords;
    vec2 modelLight;
    vec3 normal;
};



#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v) {
    vec4 worldPos = vec4(v.pos, 1.);
    vec3 norm = v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = v.modelLight;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = v.color;
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[16:59:01] [Render thread/INFO]: Loaded all shader programs.
[16:59:16] [Render thread/INFO]: OpenAL initialized on device OpenAL Soft on 扬声器 (Realtek(R) Audio)
[16:59:16] [Render thread/INFO]: Sound engine started
[16:59:16] [Render thread/INFO]: Created: 2048x1024x0 minecraft:textures/atlas/blocks.png-atlas
[16:59:16] [Render thread/INFO]: [OptiFine] Animated sprites: 71
[16:59:16] [Render thread/INFO]: Created: 256x128x4 minecraft:textures/atlas/signs.png-atlas
[16:59:16] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[16:59:16] [Render thread/INFO]: Created: 512x512x4 minecraft:textures/atlas/banner_patterns.png-atlas
[16:59:16] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[16:59:16] [Render thread/INFO]: Created: 512x512x4 minecraft:textures/atlas/shield_patterns.png-atlas
[16:59:16] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[16:59:16] [Render thread/INFO]: Created: 256x256x4 minecraft:textures/atlas/chest.png-atlas
[16:59:16] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[16:59:16] [Render thread/INFO]: Created: 512x256x4 minecraft:textures/atlas/beds.png-atlas
[16:59:16] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[16:59:16] [Render thread/INFO]: Created: 512x256x4 minecraft:textures/atlas/shulker_boxes.png-atlas
[16:59:16] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[16:59:19] [Render thread/INFO]: Created: 256x256x0 minecraft:textures/atlas/particles.png-atlas
[16:59:19] [Render thread/INFO]: [OptiFine] Animated sprites: 1
[16:59:19] [Render thread/INFO]: Created: 256x256x0 minecraft:textures/atlas/paintings.png-atlas
[16:59:19] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[16:59:19] [Render thread/INFO]: Created: 128x256x0 minecraft:textures/atlas/mob_effects.png-atlas
[16:59:19] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: minecraft:missingno
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 17, icon: minecraft:missingno
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: minecraft:missingno
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 17, icon: minecraft:missingno
[16:59:19] [Render thread/INFO]: Created: 128x256x0 jei:textures/atlas/gui.png-atlas
[16:59:19] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/config_button
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/config_button
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/config_button_cheat
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/config_button_cheat
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/arrow_previous
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/arrow_previous
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/arrow_next
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/arrow_next
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: minecraft:missingno
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: minecraft:missingno
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/info
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/info
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/recipe_transfer
[16:59:19] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/recipe_transfer
[16:59:19] [Render thread/INFO]: BookContentResourceListenerLoader preloaded 39 jsons
[16:59:19] [Render thread/INFO]: Not reloading resource pack-based books as client world is missing
[16:59:19] [Render thread/INFO]: [OptiFine] *** Reloading custom textures ***
[16:59:19] [Render thread/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[16:59:19] [Render thread/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[16:59:19] [Render thread/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[16:59:33] [Render thread/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[16:59:33] [Render thread/WARN]: [OptiFine] Model renderer not found, model: creeper, name: armor
[16:59:33] [Render thread/WARN]: [OptiFine] Model renderer not found, model: minecart, name: dirt
[16:59:33] [Render thread/WARN]: [OptiFine] Model renderer not found, model: chest_minecart, name: dirt
[16:59:33] [Render thread/WARN]: [OptiFine] Model renderer not found, model: command_block_minecart, name: dirt
[16:59:33] [Render thread/WARN]: [OptiFine] Model renderer not found, model: furnace_minecart, name: dirt
[16:59:33] [Render thread/WARN]: [OptiFine] Model renderer not found, model: hopper_minecart, name: dirt
[16:59:33] [Render thread/WARN]: [OptiFine] Model renderer not found, model: tnt_minecart, name: dirt
[16:59:33] [Render thread/WARN]: [OptiFine] Model renderer not found, model: spawner_minecart, name: dirt
[16:59:33] [Render thread/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[16:59:33] [Render thread/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[16:59:33] [Render thread/INFO]: [OptiFine] Disable Forge light pipeline
[16:59:33] [Render thread/INFO]: [OptiFine] Set ForgeConfig.CLIENT.experimentalForgeLightPipelineEnabled=false
[16:59:34] [Render thread/WARN]: [inventoryprofilesnext] Unknown config key 'first_run' with value 'false'
[16:59:34] [Render thread/WARN]: [inventoryprofilesnext] Unknown config key 'first_run' with value 'false'
[16:59:35] [Realms Notification Availability checker #1/INFO]: Could not authorize you against Realms server: Invalid session id
[17:00:07] [Render thread/INFO]: Reloading ResourceManager: Default, Mod Resources, xali's Enchanted Books v0.9.zip
[17:00:07] [Render thread/INFO]: [OptiFine] *** Reloading textures ***
[17:00:07] [Render thread/INFO]: [OptiFine] Resource packs: Mod Resources, xali's Enchanted Books v0.9.zip
[17:00:07] [Worker-Main-10/INFO]: [OptiFine] Multitexture: false
[17:00:07] [Worker-Main-13/INFO]: [OptiFine] Multitexture: false
[17:00:07] [Worker-Main-14/INFO]: [OptiFine] Multitexture: false
[17:00:07] [Worker-Main-11/INFO]: [OptiFine] Multitexture: false
[17:00:08] [Worker-Main-11/INFO]: [OptiFine] Scaled non power of 2: jei:gui/icons/recipe_transfer, 7 -> 14
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/acquisition.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: charm:acquisition
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/aerial_affinity.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: charm:aerial_affinity
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/aqua_affinity.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/bane_of_arthropods1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/bane_of_arthropods2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/bane_of_arthropods3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/bane_of_arthropods4.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/bane_of_arthropods5.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/bane_of_illager1.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: illagers_plus:illagers_bane
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/bane_of_illager2.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: illagers_plus:illagers_bane
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/bane_of_illager3.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: illagers_plus:illagers_bane
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/bane_of_illager4.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: illagers_plus:illagers_bane
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/bane_of_illager5.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: illagers_plus:illagers_bane
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/bane_of_illager6.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: illagers_plus:illagers_bane
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/bane_of_illager7.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: illagers_plus:illagers_bane
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/blast_protection.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/board_return.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: alexsmobs:board_return
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/channeling.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/curse_of_binding.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/curse_of_vanishing.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/depth_strider.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/efficiency1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/efficiency2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/efficiency3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/efficiency4.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/efficiency5.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/end_veil.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: betterendforge:end_veil
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/feather_falling.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/fire_aspect1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/fire_aspect2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/fire_protection_1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/fire_protection_2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/fire_protection_3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/fire_protection_4.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/flame.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/fortune1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/fortune2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/fortune3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/frost_walker1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/frost_walker2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/impaling1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/impaling2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/impaling3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/impaling4.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/impaling5.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/infinity.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/knockback1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/knockback2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/lavawax.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: alexsmobs:lavawax
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/looting1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/looting2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/looting3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/loyalty1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/loyalty2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/loyalty3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/luck_of_the_sea1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/luck_of_the_sea2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/luck_of_the_sea3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/lure.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/mending.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/multishot.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/night_vision.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: astralsorcery:night_vision
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/piercing.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/power1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/power2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/power3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/power4.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/power5.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/precision1.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: additionaladditions:precision
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/precision2.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: additionaladditions:precision
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/precision3.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: additionaladditions:precision
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/projectile_protection.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/protection_1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/protection_2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/protection_3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/protection_4.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/punch1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/punch2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/quick_charge1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/quick_charge2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/quick_charge3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/respiration1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/respiration2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/respiration3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/riptide1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/riptide2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/riptide3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/scorching_heat.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: astralsorcery:scorching_heat
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/serpent_friend.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: alexsmobs:serpentfriend
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/sharpness1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/sharpness2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/sharpness3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/sharpness4.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/sharpness5.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/silk_touch.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/smite1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/smite2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/smite3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/smite4.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/smite5.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/soul_speed1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/soul_speed2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/soul_speed3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/straddle_jump1.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: alexsmobs:straddle_jump
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/straddle_jump2.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: alexsmobs:straddle_jump
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/straddle_jump3.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: alexsmobs:straddle_jump
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/sweeping_edge.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/thorns1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/thorns2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/thorns3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/tinted.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: charm:tinted
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/unbreaking1.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/unbreaking2.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/unbreaking3.properties
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] CustomItems: optifine/cit/vein_mining.properties
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Invalid value: veinmining:vein_mining
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[17:00:17] [Worker-Main-15/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[17:00:17] [Worker-Main-15/WARN]: Unable to resolve texture reference: #missing in additionalguns:item/ravens_claw
[17:00:17] [Worker-Main-15/WARN]: Unable to resolve texture reference: #missing in additionalguns:item/angled_grip
[17:00:17] [Worker-Main-15/WARN]: Unable to resolve texture reference: #missing in additionalguns:item/ace_of_spades
[17:00:17] [Worker-Main-15/WARN]: Unable to resolve texture reference: #missing in additionalguns:item/ammo_jcc
[17:00:17] [Worker-Main-15/WARN]: Unable to resolve texture reference: #missing in additionalguns:item/banshee
[17:00:17] [Worker-Main-15/INFO]: [OptiFine] Multitexture: false
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] Multipass connected textures: false
[17:00:18] [Worker-Main-15/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] Multipass connected textures: false
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/00_glass_white/glass_pane_white.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/00_glass_white/glass_white.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/01_glass_orange/glass_orange.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/01_glass_orange/glass_pane_orange.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/02_glass_magenta/glass_magenta.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/02_glass_magenta/glass_pane_magenta.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/03_glass_light_blue/glass_light_blue.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/03_glass_light_blue/glass_pane_light_blue.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/04_glass_yellow/glass_pane_yellow.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/04_glass_yellow/glass_yellow.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/05_glass_lime/glass_lime.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/05_glass_lime/glass_pane_lime.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/06_glass_pink/glass_pane_pink.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/06_glass_pink/glass_pink.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/07_glass_gray/glass_gray.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/07_glass_gray/glass_pane_gray.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/08_glass_light_gray/glass_light_gray.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/08_glass_light_gray/glass_pane_light_gray.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/09_glass_cyan/glass_cyan.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/09_glass_cyan/glass_pane_cyan.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/10_glass_purple/glass_pane_purple.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/10_glass_purple/glass_purple.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/11_glass_blue/glass_blue.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/11_glass_blue/glass_pane_blue.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/12_glass_brown/glass_brown.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/12_glass_brown/glass_pane_brown.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/13_glass_green/glass_green.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/13_glass_green/glass_pane_green.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/14_glass_red/glass_pane_red.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/14_glass_red/glass_red.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/15_glass_black/glass_black.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/15_glass_black/glass_pane_black.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/20_glass/glass.properties
[17:00:18] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/20_glass/glass_pane.properties
[17:00:19] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/21_tinted_glass/tinted_glass.properties
[17:00:19] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/30_bookshelf/bookshelf.properties
[17:00:19] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/40_sandstone/sandstone.properties
[17:00:19] [Worker-Main-15/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/41_red_sandstone/red_sandstone.properties
[17:00:19] [Worker-Main-15/INFO]: [OptiFine] Multipass connected textures: false
[17:00:19] [Worker-Main-15/INFO]: [OptiFine] BetterGrass: Parsing default configuration optifine/bettergrass.properties
[17:00:27] [Worker-Main-15/INFO]: [OptiFine] Mipmap levels: 4
[17:00:27] [Worker-Main-10/ERROR]: Using missing texture, unable to load car:textures/block/bio_diesel.png : java.io.FileNotFoundException: car:textures/block/bio_diesel.png
[17:00:27] [Worker-Main-11/ERROR]: Using missing texture, unable to load car:textures/block/methanol.png : java.io.FileNotFoundException: car:textures/block/methanol.png
[17:00:28] [Worker-Main-8/ERROR]: Using missing texture, unable to load car:textures/block/glycerin.png : java.io.FileNotFoundException: car:textures/block/glycerin.png
[17:00:28] [Worker-Main-8/ERROR]: Using missing texture, unable to load car:textures/block/canola_methanol_mix.png : java.io.FileNotFoundException: car:textures/block/canola_methanol_mix.png
[17:00:28] [Worker-Main-8/ERROR]: Using missing texture, unable to load minecraft:textures/block/stone_slab_top.png : java.io.FileNotFoundException: minecraft:textures/block/stone_slab_top.png
[17:00:28] [Worker-Main-13/ERROR]: Using missing texture, unable to load car:textures/block/canola_oil.png : java.io.FileNotFoundException: car:textures/block/canola_oil.png
[17:00:28] [Worker-Main-13/ERROR]: Using missing texture, unable to load minecraft:textures/block/hardened_clay_stained_gray.png : java.io.FileNotFoundException: minecraft:textures/block/hardened_clay_stained_gray.png
[17:00:28] [Worker-Main-15/INFO]: [OptiFine] Scaled non power of 2: additionalguns:item/aos_decal_3, 17 -> 32
[17:00:28] [Worker-Main-15/INFO]: [OptiFine] Scaled non power of 2: additionalguns:item/aos_decal_2, 17 -> 32
[17:00:28] [Worker-Main-15/INFO]: [OptiFine] Scaled too small texture: additionalguns:item/vintorez_stock, 8 -> 16
[17:00:28] [Worker-Main-15/INFO]: [OptiFine] Scaled non power of 2: additionalguns:item/ravens_claw_decal, 235 -> 240
[17:00:28] [Worker-Main-15/WARN]: Texture additionalguns:item/ravens_claw_decal with size 240x63 limits mip level from 4 to 0
[17:00:28] [Worker-Main-15/INFO]: [OptiFine] Scaled non power of 2: additionalguns:item/banshee_decal, 158 -> 160
[17:00:28] [Worker-Main-15/WARN]: minecraft:textures/atlas/blocks.png: dropping miplevel from 4 to 0, because of minimum power of two: 1
[17:00:29] [Worker-Main-15/INFO]: [OptiFine] Multitexture: false
[17:00:29] [Worker-Main-15/INFO]: [OptiFine] Sprite size: 64
[17:00:29] [Worker-Main-15/INFO]: [OptiFine] Mipmap levels: 6
[17:00:29] [Worker-Main-15/WARN]: Unused frames in sprite minecraft:missingno: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
[17:00:29] [Worker-Main-15/INFO]: [OptiFine] Multitexture: false
[17:00:30] [Worker-Main-15/INFO]: [OptiFine] Sprite size: 64
[17:00:30] [Worker-Main-15/INFO]: [OptiFine] Mipmap levels: 6
[17:00:30] [Worker-Main-15/WARN]: Unused frames in sprite minecraft:missingno: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
[17:00:30] [Worker-Main-15/INFO]: [OptiFine] Multitexture: false
[17:00:30] [Worker-Main-15/INFO]: [OptiFine] Sprite size: 64
[17:00:30] [Worker-Main-15/INFO]: [OptiFine] Mipmap levels: 6
[17:00:30] [Worker-Main-15/WARN]: Unused frames in sprite minecraft:missingno: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
[17:00:30] [Worker-Main-15/INFO]: [OptiFine] Multitexture: false
[17:00:30] [Worker-Main-15/INFO]: [OptiFine] Sprite size: 64
[17:00:30] [Worker-Main-15/INFO]: [OptiFine] Mipmap levels: 6
[17:00:30] [Worker-Main-15/WARN]: Unused frames in sprite minecraft:missingno: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
[17:00:30] [Worker-Main-15/INFO]: [OptiFine] Multitexture: false
[17:00:30] [Worker-Main-15/INFO]: [OptiFine] Sprite size: 64
[17:00:30] [Worker-Main-15/INFO]: [OptiFine] Mipmap levels: 6
[17:00:30] [Worker-Main-15/WARN]: Unused frames in sprite minecraft:missingno: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
[17:00:30] [Worker-Main-15/INFO]: [OptiFine] Multitexture: false
[17:00:30] [Worker-Main-15/INFO]: [OptiFine] Sprite size: 64
[17:00:30] [Worker-Main-15/INFO]: [OptiFine] Mipmap levels: 6
[17:00:30] [Worker-Main-15/WARN]: Unused frames in sprite minecraft:missingno: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
[17:00:30] [Render thread/INFO]: No shader config found.
[17:00:30] [Render thread/INFO]: Loading context 'flywheel:context/crumbling'
[17:00:30] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in mat4 a_i_transform;
in mat3 a_i_normalMat;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Instance i;
i.light = a_i_light;
i.color = a_i_color;
i.transform = a_i_transform;
i.normalMat = a_i_normalMat;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in mat4 a_i_transform;
in mat3 a_i_normalMat;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Instance i;
i.light = a_i_light;
i.color = a_i_color;
i.transform = a_i_transform;
i.normalMat = a_i_normalMat;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in vec3 a_i_pivot;
in vec4 a_i_rotation;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Oriented i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.pivot = a_i_pivot;
i.rotation = a_i_rotation;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in vec3 a_i_pivot;
in vec4 a_i_rotation;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Oriented i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.pivot = a_i_pivot;
i.rotation = a_i_rotation;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_pos;
in vec2 a_i_light;
in float a_i_offset;
in vec3 a_i_axis;
in vec4 a_i_rotation;
in vec3 a_i_rotationCenter;
in float a_i_speed;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Actor i;
i.pos = a_i_pos;
i.light = a_i_light;
i.offset = a_i_offset;
i.axis = a_i_axis;
i.rotation = a_i_rotation;
i.rotationCenter = a_i_rotationCenter;
i.speed = a_i_speed;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_pos;
in vec2 a_i_light;
in float a_i_offset;
in vec3 a_i_axis;
in vec4 a_i_rotation;
in vec3 a_i_rotationCenter;
in float a_i_speed;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Actor i;
i.pos = a_i_pos;
i.light = a_i_light;
i.offset = a_i_offset;
i.axis = a_i_axis;
i.rotation = a_i_rotation;
i.rotationCenter = a_i_rotationCenter;
i.speed = a_i_speed;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_instancePos;
in vec2 a_i_light;
in vec3 a_i_segmentOffset;
in vec3 a_i_pivot;
in float a_i_horizontalAngle;
in float a_i_intensity;
in float a_i_flapScale;
in float a_i_flapness;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Flap i;
i.instancePos = a_i_instancePos;
i.light = a_i_light;
i.segmentOffset = a_i_segmentOffset;
i.pivot = a_i_pivot;
i.horizontalAngle = a_i_horizontalAngle;
i.intensity = a_i_intensity;
i.flapScale = a_i_flapScale;
i.flapness = a_i_flapness;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_instancePos;
in vec2 a_i_light;
in vec3 a_i_segmentOffset;
in vec3 a_i_pivot;
in float a_i_horizontalAngle;
in float a_i_intensity;
in float a_i_flapScale;
in float a_i_flapness;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Flap i;
i.instancePos = a_i_instancePos;
i.light = a_i_light;
i.segmentOffset = a_i_segmentOffset;
i.pivot = a_i_pivot;
i.horizontalAngle = a_i_horizontalAngle;
i.intensity = a_i_intensity;
i.flapScale = a_i_flapScale;
i.flapness = a_i_flapness;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;
uniform sampler2D uCrumbling;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    #if defined(USE_FOG)
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);
    #endif

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)

out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    vec4 cr = texture(uCrumbling, texCoords * uTextureScale);
    float diffuseAlpha = texture(uBlockAtlas, texCoords).a;
    cr.a = cr.a * diffuseAlpha;
    return cr;
}

void FLWFinalizeColor(vec4 color) {
    #if defined(USE_FOG)
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;
    #endif

    if (color.a < 0.1) {
        discard;
    }

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return vec4(1.);
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/INFO]: Loading context 'flywheel:context/world'
[17:00:30] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in mat4 a_i_transform;
in mat3 a_i_normalMat;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Instance i;
i.light = a_i_light;
i.color = a_i_color;
i.transform = a_i_transform;
i.normalMat = a_i_normalMat;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:30] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:30] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in mat4 a_i_transform;
in mat3 a_i_normalMat;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Instance i;
i.light = a_i_light;
i.color = a_i_color;
i.transform = a_i_transform;
i.normalMat = a_i_normalMat;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in vec3 a_i_pivot;
in vec4 a_i_rotation;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Oriented i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.pivot = a_i_pivot;
i.rotation = a_i_rotation;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in vec3 a_i_pivot;
in vec4 a_i_rotation;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Oriented i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.pivot = a_i_pivot;
i.rotation = a_i_rotation;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_pos;
in vec2 a_i_light;
in float a_i_offset;
in vec3 a_i_axis;
in vec4 a_i_rotation;
in vec3 a_i_rotationCenter;
in float a_i_speed;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Actor i;
i.pos = a_i_pos;
i.light = a_i_light;
i.offset = a_i_offset;
i.axis = a_i_axis;
i.rotation = a_i_rotation;
i.rotationCenter = a_i_rotationCenter;
i.speed = a_i_speed;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_pos;
in vec2 a_i_light;
in float a_i_offset;
in vec3 a_i_axis;
in vec4 a_i_rotation;
in vec3 a_i_rotationCenter;
in float a_i_speed;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Actor i;
i.pos = a_i_pos;
i.light = a_i_light;
i.offset = a_i_offset;
i.axis = a_i_axis;
i.rotation = a_i_rotation;
i.rotationCenter = a_i_rotationCenter;
i.speed = a_i_speed;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_instancePos;
in vec2 a_i_light;
in vec3 a_i_segmentOffset;
in vec3 a_i_pivot;
in float a_i_horizontalAngle;
in float a_i_intensity;
in float a_i_flapScale;
in float a_i_flapness;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Flap i;
i.instancePos = a_i_instancePos;
i.light = a_i_light;
i.segmentOffset = a_i_segmentOffset;
i.pivot = a_i_pivot;
i.horizontalAngle = a_i_horizontalAngle;
i.intensity = a_i_intensity;
i.flapScale = a_i_flapScale;
i.flapness = a_i_flapness;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_instancePos;
in vec2 a_i_light;
in vec3 a_i_segmentOffset;
in vec3 a_i_pivot;
in float a_i_horizontalAngle;
in float a_i_intensity;
in float a_i_flapScale;
in float a_i_flapness;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Flap i;
i.instancePos = a_i_instancePos;
i.light = a_i_light;
i.segmentOffset = a_i_segmentOffset;
i.pivot = a_i_pivot;
i.horizontalAngle = a_i_horizontalAngle;
i.intensity = a_i_intensity;
i.flapScale = a_i_flapScale;
i.flapness = a_i_flapness;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

uniform vec2 uTextureScale;
uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec2 uWindowSize;

void FLWFinalizeNormal(inout vec3 normal) {
    // noop
}

#if defined(VERTEX_SHADER)
void FLWFinalizeWorldPos(inout vec4 worldPos) {
    FragDistance = cylindrical_distance(worldPos.xyz, uCameraPos);

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif
out vec4 fragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    fragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    return texture(uLightMap, shiftLight(lightCoords));
}
#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/INFO]: Loading context 'create:context/contraption'
[17:00:31] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in mat4 a_i_transform;
in mat3 a_i_normalMat;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Instance i;
i.light = a_i_light;
i.color = a_i_color;
i.transform = a_i_transform;
i.normalMat = a_i_normalMat;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in mat4 a_i_transform;
in mat3 a_i_normalMat;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Instance i;
i.light = a_i_light;
i.color = a_i_color;
i.transform = a_i_transform;
i.normalMat = a_i_normalMat;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for flywheel:model: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif




struct Instance {
    vec2 light;
    vec4 color;
    mat4 transform;
    mat3 normalMat;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Instance i) {
    vec4 worldPos = i.transform * vec4(v.pos, 1.);

    vec3 norm = i.normalMat * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    norm = normalize(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = i.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = i.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in vec3 a_i_pivot;
in vec4 a_i_rotation;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Oriented i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.pivot = a_i_pivot;
i.rotation = a_i_rotation;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in vec3 a_i_pivot;
in vec4 a_i_rotation;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Oriented i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.pivot = a_i_pivot;
i.rotation = a_i_rotation;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for flywheel:oriented: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif






struct Oriented {
    vec2 light;
    vec4 color;
    vec3 pos;
    vec3 pivot;
    vec4 rotation;
};

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Oriented o) {
    vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, o.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = o.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = o.color;
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec3 a_i_axis;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Rotating i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.axis = a_i_axis;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:rotating: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Rotating {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec3 axis;
};




mat4 kineticRotation(float offset, float speed, vec3 axis) {
    float degrees = offset + uTime * speed * 3./10.;
    float angle = fract(degrees / 360.) * PI * 2.;

    return rotate(axis, angle);
}

#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Rotating instance) {
    mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);

    vec4 worldPos = spin * vec4(v.pos - .5, 1.);
    worldPos += vec4(instance.pos + .5, 0.);

    vec3 norm = modelToNormal(spin) * v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_pos;
in vec2 a_i_light;
in float a_i_offset;
in vec3 a_i_axis;
in vec4 a_i_rotation;
in vec3 a_i_rotationCenter;
in float a_i_speed;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Actor i;
i.pos = a_i_pos;
i.light = a_i_light;
i.offset = a_i_offset;
i.axis = a_i_axis;
i.rotation = a_i_rotation;
i.rotationCenter = a_i_rotationCenter;
i.speed = a_i_speed;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_pos;
in vec2 a_i_light;
in float a_i_offset;
in vec3 a_i_axis;
in vec4 a_i_rotation;
in vec3 a_i_rotationCenter;
in float a_i_speed;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Actor i;
i.pos = a_i_pos;
i.light = a_i_light;
i.offset = a_i_offset;
i.axis = a_i_axis;
i.rotation = a_i_rotation;
i.rotationCenter = a_i_rotationCenter;
i.speed = a_i_speed;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:contraption_actor: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Actor {
    vec3 pos;
    vec2 light;
    float offset;
    vec3 axis;
    vec4 rotation;
    vec3 rotationCenter;
    float speed;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Actor instance) {
    float degrees = instance.offset + uTime * instance.speed / 20.;
    //float angle = fract(degrees / 360.) * PI * 2.;

    vec4 kineticRot = quat(instance.axis, degrees);
    vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;

    vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = instance.light;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_instancePos;
in vec2 a_i_light;
in vec3 a_i_segmentOffset;
in vec3 a_i_pivot;
in float a_i_horizontalAngle;
in float a_i_intensity;
in float a_i_flapScale;
in float a_i_flapness;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Flap i;
i.instancePos = a_i_instancePos;
i.light = a_i_light;
i.segmentOffset = a_i_segmentOffset;
i.pivot = a_i_pivot;
i.horizontalAngle = a_i_horizontalAngle;
i.intensity = a_i_intensity;
i.flapScale = a_i_flapScale;
i.flapness = a_i_flapness;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec3 a_i_instancePos;
in vec2 a_i_light;
in vec3 a_i_segmentOffset;
in vec3 a_i_pivot;
in float a_i_horizontalAngle;
in float a_i_intensity;
in float a_i_flapScale;
in float a_i_flapness;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Flap i;
i.instancePos = a_i_instancePos;
i.light = a_i_light;
i.segmentOffset = a_i_segmentOffset;
i.pivot = a_i_pivot;
i.horizontalAngle = a_i_horizontalAngle;
i.intensity = a_i_intensity;
i.flapScale = a_i_flapScale;
i.flapness = a_i_flapness;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:flap: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Flap {
    vec3 instancePos;
    vec2 light;
    vec3 segmentOffset;
    vec3 pivot;
    float horizontalAngle;
    float intensity;
    float flapScale;
    float flapness;
};




#if defined(VERTEX_SHADER)

float toRad(float degrees) {
    return fract(degrees / 360.) * PI * 2.;
}

float getFlapAngle(float flapness, float intensity, float scale) {
    float absFlap = abs(flapness);

    float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;

    float halfAngle = angle * 0.5;

    float which = step(0., flapness); // 0 if negative, 1 if positive
    float degrees = which * halfAngle + (1. - which) * angle; // branchless conditional multiply

    return degrees;
}

BlockFrag vertex(Vertex v, Flap flap) {
    float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);

    vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
    vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);

    vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
    rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;

    vec4 worldPos = vec4(rotated, 1.);
    vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = flap.light;
    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif
    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_RAINBOW
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec2 a_v_texCoords;
in vec3 a_v_normal;
in vec2 a_i_light;
in vec4 a_i_color;
in vec3 a_i_pos;
in float a_i_speed;
in float a_i_offset;
in vec4 a_i_rotation;
in vec2 a_i_sourceTexture;
in vec4 a_i_scrollTexture;
in float a_i_scrollMult;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.texCoords = a_v_texCoords;
v.normal = a_v_normal;
Belt i;
i.light = a_i_light;
i.color = a_i_color;
i.pos = a_i_pos;
i.speed = a_i_speed;
i.offset = a_i_offset;
i.rotation = a_i_rotation;
i.sourceTexture = a_i_sourceTexture;
i.scrollTexture = a_i_scrollTexture;
i.scrollMult = a_i_scrollMult;
BlockFrag o = vertex(v, i);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:belt: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


#define PIOVER2 1.5707963268

vec4 quat(vec3 axis, float angle) {
    float halfAngle = angle * PIOVER2 / 180.0;
    vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
    return vec4(axis.xyz * cs.y,  cs.x);
}

vec4 quatMult(vec4 q1, vec4 q2) {
    // disgustingly vectorized quaternion multiplication
    vec4 a = q1.w * q2.xyzw;
    vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
    vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
    vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);

    return a + b + c + d;
}

vec3 rotateVertexByQuat(vec3 v, vec4 q) {
    vec3 i = q.xyz;
    return v + 2.0 * cross(i, cross(i, v) + q.w * v);
}

vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
    return rotateVertexByQuat(v, quat(axis, angle));
}

mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}
struct Vertex {
    vec3 pos;
    vec2 texCoords;
    vec3 normal;
};

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538





struct Belt {
    vec2 light;
    vec4 color;
    vec3 pos;
    float speed;
    float offset;
    vec4 rotation;
    vec2 sourceTexture;
    vec4 scrollTexture;
    float scrollMult;
};




#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v, Belt instance) {
    vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;

    vec4 worldPos = vec4(rotated, 1.);

    vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
    float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
    b.light = instance.light;

    #if defined(DEBUG_RAINBOW)
    b.color = instance.color;
    #elif defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = vec4(1.);
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/INFO]: Loading context 'create:context/contraption'
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:contraption_structure: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Vertex {
    vec3 pos;
    vec4 color;
    vec2 texCoords;
    vec2 modelLight;
    vec3 normal;
};



#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v) {
    vec4 worldPos = vec4(v.pos, 1.);
    vec3 norm = v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = v.modelLight;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = v.color;
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec4 a_v_color;
in vec2 a_v_texCoords;
in vec2 a_v_modelLight;
in vec3 a_v_normal;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.color = a_v_color;
v.texCoords = a_v_texCoords;
v.modelLight = a_v_modelLight;
v.normal = a_v_normal;
BlockFrag o = vertex(v);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:contraption_structure: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Vertex {
    vec3 pos;
    vec4 color;
    vec2 texCoords;
    vec2 modelLight;
    vec3 normal;
};



#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v) {
    vec4 worldPos = vec4(v.pos, 1.);
    vec3 norm = v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = v.modelLight;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = v.color;
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:contraption_structure: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define VERTEX_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Vertex {
    vec3 pos;
    vec4 color;
    vec2 texCoords;
    vec2 modelLight;
    vec3 normal;
};



#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v) {
    vec4 worldPos = vec4(v.pos, 1.);
    vec3 norm = v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = v.modelLight;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = v.color;
    #endif

    return b;
}
#endif

in vec3 a_v_pos;
in vec4 a_v_color;
in vec2 a_v_texCoords;
in vec2 a_v_modelLight;
in vec3 a_v_normal;
out vec2 v2f_texCoords;
out vec4 v2f_color;
out float v2f_diffuse;
out vec2 v2f_light;
void main() {
Vertex v;
v.pos = a_v_pos;
v.color = a_v_color;
v.texCoords = a_v_texCoords;
v.modelLight = a_v_modelLight;
v.normal = a_v_normal;
BlockFrag o = vertex(v);
v2f_texCoords = o.texCoords;
v2f_color = o.color;
v2f_diffuse = o.diffuse;
v2f_light = o.light;
}
[17:00:31] [Render thread/ERROR]: Shader compilation log for create:contraption_structure: WARNING: 0:2: warning(#62) enable/warn/disable extension is not found. Extension "GL_ARB_conservative_depth" is not supported

[17:00:31] [Render thread/ERROR]: #version 150
#extension GL_ARB_conservative_depth : enable
#define FRAGMENT_SHADER
#define DEBUG_NORMAL
#if defined(VERTEX_SHADER)
out float FragDistance;
#elif defined(FRAGMENT_SHADER)
in float FragDistance;
#endif
uniform vec4 uFogColor;
uniform vec2 uFogRange;

float cylindrical_distance(vec3 worldPos, vec3 cameraPos) {
    float distXZ = length(worldPos.xz - cameraPos.xz);
    float distY = abs(worldPos.y - cameraPos.y);
    return max(distXZ, distY);
}

float cylindrical_distance(vec3 worldPos) {
    float distXZ = length(worldPos.xz);
    float distY = abs(worldPos.y);
    return max(distXZ, distY);
}

float FLWFogFactor() {
    return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
}
// Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
vec2 shiftLight(vec2 lm) {
    return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
}


uniform sampler3D uLightVolume;

uniform sampler2D uBlockAtlas;
uniform sampler2D uLightMap;

uniform vec3 uLightBoxSize;
uniform vec3 uLightBoxMin;
uniform mat4 uModel;

uniform float uTime;
uniform mat4 uViewProjection;
uniform vec3 uCameraPos;

void FLWFinalizeNormal(inout vec3 normal) {
    mat3 m;
    m[0] = uModel[0].xyz;
    m[1] = uModel[1].xyz;
    m[2] = uModel[2].xyz;
    normal = m * normal;
}

#if defined(VERTEX_SHADER)

out vec3 BoxCoord;

void FLWFinalizeWorldPos(inout vec4 worldPos) {
    worldPos = uModel * worldPos;

    BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;

    FragDistance = max(length(worldPos.xz), abs(worldPos.y)); // cylindrical fog

    gl_Position = uViewProjection * worldPos;
}

#elif defined(FRAGMENT_SHADER)


#define ALPHA_DISCARD 0.1
// optimize discard usage
#if defined(ALPHA_DISCARD)
#if defined(GL_ARB_conservative_depth)
layout (depth_greater) out float gl_FragDepth;
#endif
#endif

in vec3 BoxCoord;

out vec4 FragColor;

vec4 FLWBlockTexture(vec2 texCoords) {
    return texture(uBlockAtlas, texCoords);
}

void FLWFinalizeColor(vec4 color) {
    float a = color.a;
    float fog = clamp(FLWFogFactor(), 0., 1.);

    color = mix(uFogColor, color, fog);
    color.a = a;

    #if defined(ALPHA_DISCARD)
    if (color.a < ALPHA_DISCARD) {
        discard;
    }
    #endif

    FragColor = color;
}

vec4 FLWLight(vec2 lightCoords) {
    lightCoords = max(lightCoords, texture(uLightVolume, BoxCoord).rg);

    return texture(uLightMap, shiftLight(lightCoords));
}

#endif


mat4 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1. - c;

    vec3 sa = axis * s;

    mat4 mr = mat4(1.);
    mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
    mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
    mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);

    return mr;
}

mat4 rotation(vec3 rot) {
    return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
}

mat3 modelToNormal(mat4 mat) {
    // Discard the edges. This won't be accurate for scaled or skewed matrices,
    // but we don't have to work with those often.
    mat3 m;
    m[0] = mat[0].xyz;
    m[1] = mat[1].xyz;
    m[2] = mat[2].xyz;
    return m;
}

float diffuse(vec3 normal) {
    vec3 n2 = normal * normal * vec3(.6, .25, .8);
    return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
}

struct BlockFrag {
    vec2 texCoords;
    vec4 color;
    float diffuse;
    vec2 light;
};

#if defined(FRAGMENT_SHADER)
void fragment(BlockFrag r) {
    vec4 tex = FLWBlockTexture(r.texCoords);

    vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;

    FLWFinalizeColor(color);
}
#endif
#define PI 3.1415926538




struct Vertex {
    vec3 pos;
    vec4 color;
    vec2 texCoords;
    vec2 modelLight;
    vec3 normal;
};



#if defined(VERTEX_SHADER)
BlockFrag vertex(Vertex v) {
    vec4 worldPos = vec4(v.pos, 1.);
    vec3 norm = v.normal;

    FLWFinalizeWorldPos(worldPos);
    FLWFinalizeNormal(norm);

    BlockFrag b;
    b.diffuse = diffuse(norm);
    b.texCoords = v.texCoords;
    b.light = v.modelLight;

    #if defined(DEBUG_NORMAL)
    b.color = vec4(norm, 1.);
    #else
    b.color = v.color;
    #endif

    return b;
}
#endif

in vec2 v2f_texCoords;
in vec4 v2f_color;
in float v2f_diffuse;
in vec2 v2f_light;
void main() {
BlockFrag o;
o.texCoords = v2f_texCoords;
o.color = v2f_color;
o.diffuse = v2f_diffuse;
o.light = v2f_light;
fragment(o);
}
[17:00:31] [Render thread/INFO]: Loaded all shader programs.
[17:00:32] [Render thread/INFO]: OpenAL initialized on device OpenAL Soft on 扬声器 (Realtek(R) Audio)
[17:00:32] [Render thread/INFO]: Sound engine started
[17:00:32] [Render thread/INFO]: Created: 2048x1024x0 minecraft:textures/atlas/blocks.png-atlas
[17:00:32] [Render thread/INFO]: [OptiFine] Animated sprites: 71
[17:00:32] [Render thread/INFO]: Created: 256x128x4 minecraft:textures/atlas/signs.png-atlas
[17:00:32] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[17:00:32] [Render thread/INFO]: Created: 512x512x4 minecraft:textures/atlas/banner_patterns.png-atlas
[17:00:32] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[17:00:32] [Render thread/INFO]: Created: 512x512x4 minecraft:textures/atlas/shield_patterns.png-atlas
[17:00:32] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[17:00:32] [Render thread/INFO]: Created: 256x256x4 minecraft:textures/atlas/chest.png-atlas
[17:00:32] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[17:00:32] [Render thread/INFO]: Created: 512x256x4 minecraft:textures/atlas/beds.png-atlas
[17:00:32] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[17:00:32] [Render thread/INFO]: Created: 512x256x4 minecraft:textures/atlas/shulker_boxes.png-atlas
[17:00:32] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[17:00:34] [Render thread/INFO]: Created: 256x256x0 minecraft:textures/atlas/particles.png-atlas
[17:00:34] [Render thread/INFO]: [OptiFine] Animated sprites: 1
[17:00:34] [Render thread/INFO]: Created: 256x256x0 minecraft:textures/atlas/paintings.png-atlas
[17:00:34] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[17:00:34] [Render thread/INFO]: Created: 128x256x0 minecraft:textures/atlas/mob_effects.png-atlas
[17:00:34] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: minecraft:missingno
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 17, icon: minecraft:missingno
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: minecraft:missingno
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 17, icon: minecraft:missingno
[17:00:34] [Render thread/INFO]: Created: 128x256x0 jei:textures/atlas/gui.png-atlas
[17:00:34] [Render thread/INFO]: [OptiFine] Animated sprites: 0
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/config_button
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/config_button
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/config_button_cheat
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/config_button_cheat
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/arrow_previous
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/arrow_previous
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/arrow_next
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/arrow_next
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: minecraft:missingno
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: minecraft:missingno
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/info
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/info
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/recipe_transfer
[17:00:34] [Render thread/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/recipe_transfer
[17:00:34] [Render thread/INFO]: BookContentResourceListenerLoader preloaded 39 jsons
[17:00:34] [Render thread/INFO]: Not reloading resource pack-based books as client world is missing
[17:00:34] [Render thread/INFO]: [OptiFine] *** Reloading custom textures ***
[17:00:34] [Render thread/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[17:00:34] [Render thread/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[17:00:34] [Render thread/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[17:00:47] [Render thread/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[17:00:47] [Render thread/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[17:00:47] [Render thread/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[17:00:47] [Render thread/INFO]: [OptiFine] Disable Forge light pipeline
[17:00:47] [Render thread/INFO]: [OptiFine] Set ForgeConfig.CLIENT.experimentalForgeLightPipelineEnabled=false
[17:00:47] [Render thread/INFO]: No shader config found.
[17:01:01] [Render thread/INFO]: Stopping!
